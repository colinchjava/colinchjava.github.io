---
layout: post
title: "Building dynamic proxies with Java ASM Library"
description: " "
date: 2023-10-20
tags: []
comments: true
share: true
---

In Java, dynamic proxies are a powerful tool that allows you to create proxy classes at runtime. These proxy classes can intercept method invocations and perform additional logic before or after the original method execution. One way to implement dynamic proxies in Java is by using the ASM library.

## What is the ASM library?

The ASM library is a popular bytecode manipulation library for Java. It provides a low-level API that enables developers to dynamically generate, transform, and inspect Java bytecode. ASM is widely used in frameworks and libraries that require dynamic code generation, such as Hibernate and Spring Framework.

## Creating a dynamic proxy with ASM

To create a dynamic proxy with the ASM library, you will need to perform the following steps:

1. Define the proxy interface: Start by defining the interface that the proxy class will implement. This interface should declare the methods that you want the proxy to intercept.

2. Implement the MethodVisitor: Create a class that extends the `org.objectweb.asm.MethodVisitor` class. This class will be responsible for generating bytecode instructions for the proxy methods.

3. Implement the ClassVisitor: Create a class that extends the `org.objectweb.asm.ClassVisitor` class. This class will visit the proxy class and its methods.

4. Generate the bytecode: Use the ASM library to generate the bytecode for the proxy class and its methods. You can do this by visiting the class and its methods using your custom ClassVisitor and MethodVisitor implementations.

5. Create the proxy class: Finally, use a `ClassLoader` to load the generated bytecode and instantiate the proxy class. This class will implement the proxy interface and intercept method invocations according to your custom logic.

## Example code

```java
package com.example.proxy;

import org.objectweb.asm.*;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DynamicProxyBuilder {

    public static <T> T createProxy(Class<T> interfaceClass, InvocationHandler handler) throws Exception {
        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        String proxyClassName = interfaceClass.getName() + "Proxy";

        classWriter.visit(Opcodes.V11, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL, proxyClassName, null,
                "java/lang/Object", new String[]{Type.getInternalName(interfaceClass)});

        // Implement the proxy methods
        Method[] methods = interfaceClass.getMethods();
        for (Method method : methods) {
            MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC, method.getName(),
                    Type.getMethodDescriptor(method), null, null);
            methodVisitor.visitCode();
            // Add your custom logic here
            methodVisitor.visitEnd();
        }

        classWriter.visitEnd();
        byte[] classBytes = classWriter.toByteArray();

        ClassLoader classLoader = DynamicProxyBuilder.class.getClassLoader();
        Class<?> proxyClass = classLoader.defineClass(proxyClassName, classBytes, 0, classBytes.length);
        return interfaceClass.cast(Proxy.newProxyInstance(classLoader, new Class<?>[]{interfaceClass}, handler));
    }
}
```

## Usage

To use the dynamic proxy builder, you can simply call the `createProxy` method and provide the interface class and the `InvocationHandler` implementation. Here's an example:

```java
package com.example.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public interface Foo {
    void bar();
}

public class FooInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Perform custom logic before method invocation
        Object result = method.invoke(proxy, args);
        // Perform custom logic after method invocation
        return result;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Foo fooProxy = DynamicProxyBuilder.createProxy(Foo.class, new FooInvocationHandler());
        fooProxy.bar();
    }
}
```

## Conclusion

Dynamic proxies allow you to implement cross-cutting concerns and add additional functionality to your code at runtime. The ASM library provides a powerful and flexible way to generate dynamic proxies in Java by manipulating bytecode. By understanding the basics of ASM and following the steps outlined in this article, you can build dynamic proxies that fit your specific requirements.

# References
- ASM - Java bytecode manipulation framework: https://asm.ow2.io/
- Java Dynamic Proxy: https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/Proxy.html
- Hibernate: https://hibernate.org/
- Spring Framework: https://spring.io/